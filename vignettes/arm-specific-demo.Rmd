---
title: "Demonstration of arm-specific frailty"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Arm-specific frailties with varying frailty coefficients}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Data simulation

TODO(LCOMM): add problem setup

```{r}
options(mc.cores = parallel::detectCores() - 1)
set.seed(123)
n <- 500

# simulate with arm-specific (ftype 2) and 
# transition-specific frailty coefs (fctype 4)
dat_list <- simulate_entire_truth(n, ftype = 2, fctype = 3)
dat <- dat_list$dat
dat$tx <- rbinom(n, size = 1, prob = 0.5)
dat$yr <- ifelse(dat$tx, dat$R1, dat$R0)
dat$dyr <- ifelse(dat$tx, dat$deltaR1, dat$deltaR0)
dat$yt <- ifelse(dat$tx, dat$D1, dat$D0)
dat$dyt <- ifelse(dat$tx, dat$deltaD1, dat$deltaD0)
```

## Examining simulated data

```{r}
library("survival")
# Plots
km_r <- survfit(Surv(yr, dyr) ~ tx, data = dat)
plot(km_r, mark.time = T, col = 1:2, main = "Rehospitalization")

km_t_no_r <- survfit(Surv(yt, dyt) ~ tx, data = dat[dat$dyr == 0,])
plot(km_t_no_r, mark.time = T, col = 1:2, main = "Death among unrehospitalized")

km_soj <- survfit(Surv(yt - yr, dyt) ~ tx, data = dat[dat$dyr == 1,])
plot(km_soj, mark.time = T, col = 1:2, main = "Sojourn to death")
```

## Fit semicompeting risks model

### Stan model code

The arm-specific model with varying frailties is coded in `scr2.stan`.

```{r, code = readLines("../src/stan_files/scr2.stan"), eval = FALSE}
```
TODO(LCOMM): explain code

Fit the model using the built-in function.
```{r}
# Design matrices (one for each hazard model)
x_1 <- x_2 <- x_3 <- cbind(dat$X1, dat$X2, dat$X3)

# Stan fit
sf <- scr2_stan(dat$tx, x_1 = x_1, x_2 = x_2, x_3 = x_3, 
                yr = dat$yr, dyr = dat$dyr, yt = dat$yt, dyt = dat$dyt,
                chains = 4, iter = 2000)
```

TODO(LCOMM): fix divergent transitions

# Validation of parameter estimation

TODO(LCOMM): show estimates are near data generating parameters

Let's compare posterior means to the true data-generating parameters:
```{r}
# Function to plot vectors of parameters
plot_intervals_truth <- function(stan_fit, truth_list, par, ...) {
  stopifnot(par %in% names(truth_list))
  stopifnot(par %in% names(extract(stan_fit)))
  draws <- as.array(stan_fit, par = par)
  truth <- truth_list[[par]]
  stopifnot(length(truth) == dim(draws)[3])
  if (length(truth) > 1) {
    p <- length(truth)
    names(truth) <- paste0(par, "[", 1:p, "]")
  } else {
    names(truth) <- par
  }
  mcmc_recover_intervals(x = draws, true = truth, ...)
}
```

```{r, fig.width = 6, fig.height = 5}
library("bayesplot")
library("rstan")

truth <- list()
truth$omega1 <- dat_list$coefs$control$rcoefs[-1, 1]
truth$omega2 <- dat_list$coefs$control$rcoefs[-1, 2]
truth$omega3 <- dat_list$coefs$control$rcoefs[-1, 3]
truth$kappa <- c(dat_list$coefs$control$rcoefs[1,],
                dat_list$coefs$treated$rcoefs[1,])
truth$alpha <- c(dat_list$coefs$control$shapes,
                dat_list$coefs$treated$shapes)
truth$beta <- c(dat_list$coefs$control$fcoefs,
                dat_list$coefs$treated$fcoefs)

# Plots
plot_intervals_truth(sf, truth, "omega1")
plot_intervals_truth(sf, truth, "omega2")
plot_intervals_truth(sf, truth, "omega3")
plot_intervals_truth(sf, truth, "kappa")
plot_intervals_truth(sf, truth, "alpha")
plot_intervals_truth(sf, truth, "beta")
```

